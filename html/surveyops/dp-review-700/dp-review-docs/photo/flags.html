<!--#include virtual="/includes/sdss_page_top.html"-->
<!--#include virtual="/includes/sdss_page_surveyops.html"-->

<HTML>
<TITLE>How the Frames Pipeline Sets its Flags</TITLE>
<AUTHOR>Robert Lupton</AUTHOR>

<H1><A NAME="intro">How the Frames Pipeline Sets its Flags</A></H1>
<H3>Photo version $Name:  $</H3>

<P>

The frames pipeline uses a set of flags for each object to call
attention to possible problems and to record decisions made during
processing.  These flags apply both to the object as a whole (including
data from each band), and to each band separately.
<P>

An <CODE>OBJC</CODE> is the entire object in its polychromatic glory, while
an <CODE>OBJECT1</CODE> is the measured object in just one of the bands.
<P>

Reading the following description will be easier if you have a nodding
acquaintance with the frames pipeline, but it should be useful to all.

<DL>
<DT><A HREF="#descrip">The Flags that Frames Uses</A>
<DD>A description of each flag

<DT><A HREF="#flow">When and Where Flags are Set as Frames Runs</A>
<DD>Pseudo-code describing how the flags are set
</DL>


<H2><A NAME="descrip">The Flags that Frames Uses</A></H2>

As of version V4_8, photo has two sets of flags, <CODE>flags</CODE>
and <CODE>flags2</CODE>. There is no essential difference between the
two; the first 32 bits if information are set in <CODE>flags</CODE>
and the remainder in <CODE>flags2</CODE>. Flags in the former have
names beginning <CODE><A HREF="#flag1_0">OBJECT1_</A></CODE>,
in the latter they begin
<CODE><A HREF="#flag2_0">OBJECT2_</A></CODE>.
<P>

<DL>
<DT> <A NAME="flag1_0">0</A>  OBJECT1_CANONICAL_CENTER
<DD> The quantities (psf counts, model fits and likelihoods) that are
usually determined at an object's centre as determined band-by-band
were in fact determined at the canonical centre (suitably transformed).

<P>
This is due to the object being to close to the edge to extract a profile
at the local centre, and OBJECT1_EDGE is also set.


<DT> <A NAME="flag1_1">1</A>  OBJECT1_BRIGHT
<DD>
<UL>
<LI> For OBJECT1s, indicates that the object was detected as a bright object
<LI> For OBJCs, indicates that the object was measured as a bright object;
it'll have been remeasured later as a faint object, and these measurements
are recorded as a sibling of the original, bright, OBJC.
<P>
Internally to the frames pipeline, more objects are detected as bright objects
than are measured as such (the balance are used to tweak the astrometry);
only those objects measured will have OBJECT1_BRIGHT set.
</UL>


<DT> <A NAME="flag1_2">2</A>  OBJECT1_EDGE
<DD> Object is too close to edge of frame in this band.
Specifically, at least one of the following is true:
<UL>
<LI> At least one pixel above the detection threshold touched the edge of the
frame
<LI> The object was too close to the edge of the frame to be centroided
satisfactorily. OBJECT1_PEAKCENTER will also be set.
<LI> Object was too close to edge of frame to be able to measure a radial
profile. In this case, OBJECT1_NOPETRO and OBJECT1_NOPROFILE will also be set,
and no further attempt will be made to measure the object.
<LI> When running the deblender, at least one child in at least one band
extends beyond the field.
<LI>
The centre determined in OBJECT1's own band was too close to the edge of the
frame, although the canonical centre was not. OBJECT1_CANONICAL_CENTER
is also set, and the (transformed) canonical centre is used.
</UL>

<P>
OBJECT1_EDGE objects will have OBJECT1_NODEBLEND set, and
the object will not be deblended.

<P>
If OBJECT1_EDGE is set in any band, it will be set for the OBJC. Children
inherit this flag.


<DT> <A NAME="flag1_3">3</A>  OBJECT1_BLENDED
<DD> Object was determined to be a blend. The flag is set if:
<UL>
<LI> More than one peak is detected within an object in a single band
together
<LI> Distinct peaks are found when merging different colours of one object
together
<LI> Distinct peaks result when merging different objects together
</UL>

<P>
If OBJECT1_EDGE is set in any band, it will be set for all
bands, and for the OBJC itself.

<P>
If, while running the deblender, it so happens that only one child remains,
this flag is turned <EM>off</EM>.


<DT> <A NAME="flag1_4">4</A>  OBJECT1_CHILD
<DD> Object is a child, created by the deblender. This flag is set in all
bands, and also in the OBJC.


<DT> <A NAME="flag1_5">5</A>  OBJECT1_PEAKCENTER
<DD> Given centre is position of peak pixel, as attempts to determine a
better centroid failed.

<P>
This flag is inherited by children. (XXX can it ever be set for an OBJC?)


<DT> <A NAME="flag1_6">6</A>  OBJECT1_NODEBLEND
<DD> Although this object was marked as a blend, no deblending was attempted.
This can happen because:
<UL>
<LI> The object had OBJECT1_EDGE set
<LI> The object had too many peaks; in this case OBJECT1_DEBLEND_TOO_MANY_PEAKS
will be set.
<LI> The object was too large (larger than half a frame); in this case
OBJECT1_TOO_LARGE will be set.
<LI> While attempting to deblend the object, at least one child overlapped the
edge of the frame in at least one band. OBJECT1_EDGE will be set.
</UL>


<DT> <A NAME="flag1_7">7</A>  OBJECT1_NOPROFILE
<DD> Frames couldn't extract a radial profile. This can be caused by:
<UL>
<LI> Object being too close to edge of frame. In this case,
OBJECT1_EDGE and OBJECT1_NOPETRO are also set, and the object's properties
are not measured
<LI> There are less than two points in the radial profile. The flags
OBJECT1_NOPETRO, OBJECT1_ELLIPFAINT, and OBJECT1_NOSTOKES are set, and
Petrosian quantities, Stokes parameters, and isophotal properties
are not measured.
</UL>

<DT> <A NAME="flag1_8">8</A>  OBJECT1_NOPETRO
<DD> No Petrosian radius or other Petrosian quanties could be measured.
This can be caused by:
<UL>
<LI> Failing to measure at least two points of the radial profile;
OBJECT1_NOPROFILE is also set.
<LI> The central value of the object being impossibly negative; OBJECT1_BADSKY
is set
<LI> The Petrosian ratio never equals the value at which the Petrosian radius
is defined, or the surface
brightness when it <EM>does</EM> reach that value is too low; in the
latter case OBJECT1_PETROFAINT is set.
</UL>

<P>
This flag is inherited by the OBJC.


<DT> <A NAME="flag1_9">9</A>  OBJECT1_MANYPETRO
<DD> Object has more than one possible Petrosian radius.

<P>
This flag is inherited by the OBJC.


<DT> <A NAME="flag1_10">10</A>  OBJECT1_NOPETRO_BIG
<DD> The Petrosian ratio has not fallen to the value at which the Petrosian
radius is defined at the outermost point of the extracted radial profile.
OBJECT1_NOPETRO is set, and the "Petrosian radius" is set to the outermost
point in the profile.


<DT> <A NAME="flag1_11">11</A>  OBJECT1_DEBLEND_TOO_MANY_PEAKS
<DD> The object had the OBJECT1_DEBLEND flag set, but it contained too many
candidate children to be fully deblended.
Only the brightest <CODE>nchild_max</CODE> peaks are considered; the
value of <CODE>nchild_max</CODE> is an input parameter to the frames pipeline.


<DT> <A NAME="flag1_12">12</A>  OBJECT1_CR
<DD> Object contains at least one pixel which was contaminated by a cosmic
ray. The OBJECT1_INTERP flag is also set.


<DT> <A NAME="flag1_13">13</A>  OBJECT1_MANYR50
<DD> More than one radius was found to contain 50% of the Petrosian flux.
(For this to happen part of the radial profile must be <EM>negative</EM>)


<DT> <A NAME="flag1_14">14</A>  OBJECT1_MANYR90
<DD> More than one radius was found to contain 90% of the Petrosian flux.
(For this to happen part of the radial profile must be <EM>negative</EM>)


<DT> <A NAME="flag1_15">15</A>  OBJECT1_BAD_RADIAL
<DD> Measured profile includes points with a S/N &lt= 0.  In practice
this flag is essentially meaningless, and it may be withdrawn in the future.


<DT> <A NAME="flag1_16">16</A>  OBJECT1_INCOMPLETE_PROFILE
<DD> A circle, centred on the object, of radius the
"canonical" Petrosian radius extends beyond the edge of the frame.
The radial profile is still measured from those parts of the object
that <EM>do</EM> lie on the frame.


<DT> <A NAME="flag1_17">17</A>  OBJECT1_INTERP
<DD> The object contains interpolated pixels (e.g. cosmic rays or bad columns).
See also <A HREF="#flag2_12">OBJECT2_INTERP_CENTER</A>.


<DT> <A NAME="flag1_18">18</A>  OBJECT1_SATUR
<DD> The object contains saturated pixels; OBJECT1_INTERP is also set.
See also <A HREF="#flag2_11">OBJECT2_SATUR_CENTER</A>.
                                    

<DT> <A NAME="flag1_19">19</A>  OBJECT1_NOTCHECKED
<DD> Object includes pixels that were not checked for peaks, for example
the unsmoothed edges of frames, and the cores of subtracted or
saturated stars.  If no peaks are found in the <EM>checked</EM> part
of the object it is rejected. Note that bright stars are detected
before the wings are subtracted.


<DT> <A NAME="flag1_20">20</A>  OBJECT1_SUBTRACTED
<DD> Object (presumably a star) had wings subtracted


<DT> <A NAME="flag1_21">21</A>  OBJECT1_NOSTOKES
<DD> Object has no measured Stokes params. This can happen because:
<UL>
<LI> The object had fewer than two points in its radial profile
<LI> There were numerical difficulties in calculating either U or Q
</UL>

<DT> <A NAME="flag1_22">22</A>  OBJECT1_BADSKY
<DD> The estimated sky level is so bad that the central value of the
radial profile is crazily negative; this is usually the result of
the subtraction of the wings of bright stars failing.


<DT> <A NAME="flag1_23">23</A>  OBJECT1_PETROFAINT
<DD> At least one candidate Petrosian radius occured at an unacceptably
low surface brightness; this can lead to OBJECT1_NOPETRO being set.

<DT> <A NAME="flag1_24">24</A>  OBJECT1_TOO_LARGE
<DD> The object is (as it says) too large. The two ways that this can
be set are:
<UL>
<LI> The object is still detectable at the outermost point of the
extracted radial profile (a radius of approximately 260 arcsec)
<LI> When attempting to deblend an object, at least one child is larger
than half a frame (in either row or column). In this case, OBJECT1_NODEBLEND
is set, and the attempt to deblend is abandoned.
</UL>


<DT> <A NAME="flag1_25">25</A>  OBJECT1_DEBLENDED_AS_PSF
<DD> When deblending an object, in this band this child was treated as a PSF.
The two ways that this can happen are:
<UL>
<LI> The child is consistent with being a star
<LI> The child is not detected; in this case the OBJECT1_BINNED1 
flags will not be set. Note that this can happen if an object is
superimposed on the wings of a brighter object.
</UL>


<DT> <A NAME="flag1_26">26</A>  OBJECT1_DEBLEND_PRUNED
<DD> When solving for the weights to be assigned to each child the deblender
encountered a nearly singular matrix, and therefore deleted at least one
of them.

<P>
This flag is propagated to the OBJC.


<DT> <A NAME="flag1_27">27</A>  OBJECT1_ELLIPFAINT
<DD> No isophotal fits were performed. Possible reasons are:
<UL>
<LI> There are less than two points in the radial profile
<LI> The object's centre is fainter than desired isophote
<LI> We were unable to fit an ellipse to the desired isophote, or to the
ones a little brighter and fainter used in estimating sensitivity to
photometric calibration
</UL>


<DT> <A NAME="flag1_28">28</A>  OBJECT1_BINNED1
<DD> The object was detected in an unbinned image


<DT> <A NAME="flag1_29">29</A>  OBJECT1_BINNED2
<DD> The object was detected in a 2x2 binned image after all unbinned
detections have been replaced by the background level


<DT> <A NAME="flag1_30">30</A>  OBJECT1_BINNED4
<DD> The object was detected in a 4x4 binned image. The objects detected
in the 2x2 binned image are <EM>not</EM> removed before doing this.


<DT> <A NAME="flag1_31">31</A>  OBJECT1_MOVED
<DD> The object appears to have moved during the exposure. Such objects are
candidates to be deblended as moving objects; see
<A HREF="#flag2_0">OBJECT2_DEBLENDED_AS_MOVING</A>.


<DT> <A NAME="flag1_32">32</A> OBJECT1_DETECTED
<DD> A meta-flag, defined as:
<PRE>
(OBJECT1_BINNED1 | OBJECT1_BINNED2 | OBJECT1_BINNED4)                [<A HREF="#flag1_28">28</A>,<A HREF="#flag1_29">29</A>,<A HREF="#flag1_30">30</A>]
</PRE>
</DL>

Now for the <CODE>OBJECT2</CODE> flags:

<DL>
<DT> <A NAME="flag2_0">0</A> OBJECT2_DEBLENDED_AS_MOVING
<DD>
The object has the <A HREF="#flag1_31">OBJECT1_MOVED</A>
flag set, and was deblended on the assumption that it was moving.

<DT> <A NAME="flag2_1">1</A> OBJECT2_NODEBLEND_MOVING
<DD>
A blend labelled <A HREF="#flag1_31">OBJECT1_MOVED</A> was not deblended as
a moving object.

<DT> <A NAME="flag2_2">2</A> OBJECT2_TOO_FEW_DETECTIONS
<DD>
The object has the <A HREF="#flag1_31">OBJECT1_MOVED</A>
flag set, but was detected in too few bands to be reliably deblended
as moving; <A HREF="#flag1_6">OBJECT1_NODEBLEND</A> will also be set.

<DT> <A NAME="flag2_3">3</A> OBJECT2_BAD_MOVING_FIT
<DD>
Fit to moving object was too poor to be believable.
If a candidate moving object, is wasn't deblended as moving.

<DT> <A NAME="flag2_4">4</A> OBJECT2_STATIONARY
<DD>
A "moving" object's velocity is consistent with zero


<DT> <A NAME="flag2_5">5</A> OBJECT2_PEAKS_TOO_CLOSE
<DD>
Peaks in object were too close XXX


<DT> <A NAME="flag2_6">6</A> OBJECT2_MEDIAN_CENTRE
<DD>
Quoted centre of object is based on a median-smoothed version of image.
<EM>Not currently set</EM>.

<DT> <A NAME="flag2_7">7</A> OBJECT2_LOCAL_EDGE
The object's centre in some band was too close to the edge of the frame
to extract a profile. For extended objects, this may only be the case
after binning; see the quoted errors in rowc and colc.


<DT> <A NAME="flag2_8">8</A> OBJECT2_BAD_COUNTS_ERROR
An object containing interpolated pixels had too few good pixels to form
a reliable estimate of its error; the quoted error may be
<EM>under</EM>estimated


<DT> <A NAME="flag2_9">9</A> OBJECT2_BAD_MOVING_FIT_CHILD
<DD> moving child's fit was too poor
An object containing interpolated pixels had too few good pixels to form
a reliable estimate of its error; the quoted error may be
<EM>under</EM>estimated


<DT> <A NAME="flag2_10">10</A> OBJECT2_DEBLEND_UNASSIGNED_FLUX
<DD> After deblending, the fraction of flux assigned to none of the
children was too large (this flux is then shared out as described
elsewhere).

<DT> <A NAME="flag2_11">11</A> OBJECT2_SATUR_CENTER
<DD> An object's centre is very close to at least one saturated pixel;
the object may well be causing the saturation.

<DT> <A NAME="flag2_12">12</A> OBJECT2_INTERP_CENTER
<DD> An object's centre is very close to at least one interpolated pixel.

<DT> <A NAME="flag2_13">13</A> OBJECT2_DEBLENDED_AT_EDGE
<DD> An object so close to the edge of the frame that it would not
ordinarily be deblended has been deblended anyway.  Only set for
objects large enough to be <A HREF="#flag1_2">EDGE</A> in all fields/strips.

<DT> <A NAME="flag2_14">14</A> OBJECT2_DEBLEND_NOPEAK
<DD> A child had no detected peak in a given band, but we centroided it
anyway and set the <A HREF="#flag1_28">BINNED1</A>

<DT> <A NAME="flag2_15">15</A> OBJECT2_PSF_FLUX_INTERP
<DD> The fraction of light actually detected (as opposed to guessed at
by the interpolator) was less than some number (currently 80%) of
the total.

</DL>

The following flag2 bits will never be set in output files, but they
are used internally and are therefore included in this document.
<DL>
                                    
<DT> <A NAME="flag2_28">28</A> OBJECT2_MEASURED
<DD> This object's properties have been measured.

<DT> <A NAME="flag2_29">29</A> OBJECT2_GROWN_MERGED
<DD> Growing this object after it had been detected (maybe as
a single pixel over threshold) led to a merger.

<DT> <A NAME="flag2_30">30</A> OBJECT2_HAS_CENTER
<DD> This OBJC has a canonical centre.

<DT> <A NAME="flag2_31">31</A> OBJECT2_MEASURE_BRIGHT
<DD> This BRIGHT object should be measured, not just treasured for
its astrometric properties.
</DL>
                                    


<H2><A NAME="flow">When and Where Flags are Set as Frames Runs</A></H2>

The variable objc refers to an <CODE><A HREF="#intro">OBJC</A></CODE>,
while object1 refers to an <CODE><A HREF="#intro">OBJECT1</A></CODE>.
You are expected to imagine a loop over all filters, setting flags
as appropriate.

<P>
The following pseudo-code roughly corresponds to the organisation of the
frames pipeline, and bears some resemblence to C. The following idioms
are used:
<DL>
<DT> var |= FLAG;
<DD> Set the FLAG bit in the variable var

<DT> if(var & FLAG)
<DD> Is var's FLAG bit set?

<DT> var &= ~FLAG;
<DD> Clear the FLAG bit in the variable var
</DL>

<P>
The numbers in the right hand margin refer to the previous section, where
the individual flags are described.

<PRE>
find_objects
{
   if(pixels over threshold touch edge of frame) {
      object1->flags |= OBJECT1_EDGE;                                      [<A HREF="#flag1_2">2</A>]
   }
   if(object includes unsearched pixels (e.g. unsmoothed edges of frames)) {
      object1->flags |= OBJECT1_NOTCHECKED;                                [<A HREF="#flag1_19">19</A>]
      reject all peaks in NOTCHECKED parts of frame;
   }
/*
 * information about which mode object was detected in
 */
   if(bright objects) {
      object1->flags |= OBJECT1_BRIGHT;                                    [<A HREF="#flag1_1">1</A>]
   }

   if(not binned) {
      object1->flags |= OBJECT1_BINNED1;                                   [<A HREF="#flag1_28">28</A>]
   } else if(binned 2x2) {
      object1->flags |= OBJECT1_BINNED2;                                   [<A HREF="#flag1_29">29</A>]
   } else if(binned 4x4) {
      object1->flags |= OBJECT1_BINNED4;                                   [<A HREF="#flag1_30">30</A>]
   }
/*
 * information about pixels contained in object
 */
   if(object contains interpolated pixels) {
      object1->flags |= OBJECT1_INTERP;                                    [<A HREF="#flag1_17">17</A>]

      if(object contains cosmic ray contaminated pixels) {
         object1->flags |= OBJECT1_CR;                                     [<A HREF="#flag1_12">12</A>]
      }

      if(object contains saturated pixels after centering on peak) {
         object1->flags |= OBJECT1_SATUR;                                  [<A HREF="#flag1_18">18</A>]
      }
   }
}
</PRE>

<PRE>
find_centre
{
   if((object1->flags & OBJECT1_SATUR) && saturated star centroider fails) { [<A HREF="#flag1_18">18</A>]
      object1->flags |= OBJECT1_PEAKCENTER;                                [<A HREF="#flag1_5">5</A>]
   }
   
   for(;;) {
      find_peak_centre;

      if(centre is OK && width estimate is consistent with size of object) {
         break;
      }

      if(too close to edge while searching for peak) {
         object1->flags |= OBJECT1_EDGE | OBJECT1_PEAKCENTER;              [<A HREF="#flag1_2">2</A>,<A HREF="#flag1_5">5</A>]
         break;
      }
   
      if(object has vanishing second derviative || centroider fails otherwise) {
         object1->flags |= OBJECT1_PEAKCENTER;                             [<A HREF="#flag1_5">5</A>]
         break;
      }

      bin image in row/and or column;
   }

   if(object1->flags & OBJECT1_PEAKCENTER) {                               [<A HREF="#flag1_5">5</A>]
      take centre of brightest pixel as peak position;
   }
}
</PRE>

<PRE>
merge_colors
{
   merge together peaks in saturated cores;

   if(more than one peaks is detected within an object in one band) {
      objc->flags |= OBJECT1_BLENDED;                                      [<A HREF="#flag1_3">3</A>]
   }

   if(distinct peaks found in different bands of same object) {
      objc->flags |= OBJECT1_BLENDED;                                      [<A HREF="#flag1_3">3</A>]
   }

   if(multiple distinct peaks in merged objects) {
      objc->flags |= OBJECT1_BLENDED;                                      [<A HREF="#flag1_3">3</A>]
   }

   if(obj1 and obj2 are to be merged) {
      if((!(obj1->flags & OBJECT1_DETECTED) &&
           (obj2->flags & OBJECT1_DETECTED)) ||                            [<A HREF="#flag1_32">32</A>]
          (obj1->flags & OBJECT1_CANONICAL_CENTER)) {                      [<A HREF="#flag1_0">0</A>]
         use obj2;
      } else if(((obj1->flags & OBJECT1_DETECTED) &&
                !(obj2->flags & OBJECT1_DETECTED)) ||                      [<A HREF="#flag1_32">32</A>]
                (obj2->flags & OBJECT1_CANONICAL_CENTER)) {                [<A HREF="#flag1_0">0</A>]
         use obj1;
      } else {
         use the one with the brighter peak;
      }
   }
}
</PRE>

<PRE>
subtract_bright_stars
{
   if(object1->flags & OBJECT1_EDGE) {                                     [<A HREF="#flag1_2">2</A>]
      don't subtract wings;
      return;
   }

   if(object1->flags & OBJECT1_SATUR) {                                    [<A HREF="#flag1_18">18</A>]
      estimate psfCounts from profile;
      if(more than 20% of counts are interpolated) {
         object1->flags2 |= OBJECT2_PSF_FLUX_INTERP;                       [<A HREF="#flag2_15">15</A>]
      }
   }

   if(object contains pixels from which star wings were subtracted) {
      object1->flags |= OBJECT1_SUBTRACTED;                                [<A HREF="#flag1_20">20</A>]
   }
   if(object is in part of frame where bright star wings exceeded 10 sky sigma,
                           or star wings increased variance by more than 50%) {
      object1->flags |= OBJECT1_NOTCHECKED;                                [<A HREF="#flag1_19">19</A>]
      
   }
}
</PRE>

<PRE>
peak_up_astrometry
{
      !(object1 & (OBJECT1_CANONICAL_CENTER |                              [<A HREF="#flag1_0">0</A>]
                   OBJECT1_PEAKCENTER |                                    [<A HREF="#flag1_5">5</A>]
   if(!(object1->flags & OBJECT1_DETECTED) ||                              [<A HREF="#flag1_32">32</A>]
      (object1->flags & (OBJECT1_SATUR | OBJECT1_PEAKCENTER))) {           [<A HREF="#flag1_18">18</A>][<A HREF="#flag1_5">5</A>]
      Don't use star in matchup
   }
}
</PRE>

<PRE>
measure_objects
{
/*
 * book keeping
 */
   if(detected as a bright object) {
      if(measuring bright objects &&
         !(objc->flags2 & OBJECT2_MEASURE_BRIGHT)) {                       [<A HREF="#flag2_31">1</A>]
         don't measure object;
	 return;
      }
      if(being remeasured after faint object detection) {
         make new object which is sibling of bright object,
         and prepare to measure this new creation;
         unset OBJECT1_BRIGHT in objc and object1;                         [<A HREF="#flag1_1">1</A>]
      }
   }

   recentroid_and_find_canonical_centre {
      foreach object1 in objc {
         if(objc->flags2 & OBJECT2_DEBLENDED_AS_MOVING) {                     [<A HREF="#flag2_0">0</A>]
            we already have a good centre;
            continue;
         }

         if(!(detected in this band)) {
	    if(!child)
	       continue;
            }

            set centre from objc;
	    object1->flags |= OBJECT1_CANONICAL_CENTER | OBJECT1_BINNED1;    [<A HREF="#flag1_0">0</A>,<A HREF="#flag1_28">28</A>]

	    object1->flags2 |= OBJECT2_DEBLEND_NOPEAK;                       [<A HREF="#flag2_14">14</A>]
         }
      }

      find_canonical_centre {
         object1 = object1 in canonical band;
	 if(object1->flags & OBJECT1_DETECTED &&                            [<A HREF="#flag1_32">32</A>]
            !(object1->flags) & OBJECT1_SATUR) {                            [<A HREF="#flag1_18">18</A>]
            use this object1's centre;
         } else if(at least one peak is non-saturated) {
            use brightest non-saturated peak;
         } else {
            use brightest peak;
         }

         convert to canonical band's coordinate system;
      }
   }

   create_object1s {
      foreach (missing OBJECT1) {
	 make object1;
	 if(bright) {
            object1->flags |= OBJECT1_BRIGHT;                              [<A HREF="#flag1_1">1</A>]
         }
      	 set centre from OBJC;
         object1->flags |= OBJECT1_CANONICAL_CENTER;                       [<A HREF="#flag1_0">0</A>]
      }

      if(blended) {
         objc->flags |= object1->flags & OBJECT1_BLENDED;                  [<A HREF="#flag1_3">3</A>]
      }
   }

   if(!(objc->flags & OBJECT1_BRIGHT)) {                                   [<A HREF="#flag1_1">1</A>]
      save atlas images;
   }
/*
 * set sky level
 */
   if(object1->flags & OBJECT1_CHILD) {                                    [<A HREF="#flag1_4">4</A>]
      sky += contribution from siblings;
      if(sky summation failed &&
         child->flags2 & (OBJECT2_DEBLENDED_AT_EDGE |                      [<A HREF="#flag2_13">13</A>]
                          OBJECT2_DEBLENDED_AS_MOVING)) {                  [<A HREF="#flag2_0">0</A>]
         sky = sky level at child's centre;
      } else {
         This cannot happen, so die;
      }
   }
/*
 * extract profile;
 */
   if(failed to extract radial profile) {
      object1->flags |= OBJECT1_EDGE | OBJECT1_NOPETRO | OBJECT1_NOPROFILE;
      object1->flags2 |= OBJECT2_LOCAL_EDGE;                            [<A HREF="#flag2_7">7</A>]
      give up measuring object in this band;                            [<A HREF="#flag1_2">2</A>,<A HREF="#flag1_7">7</A>,<A HREF="#flag1_8">8</A>]
   }

   if(pixel overflow while extracting radial profile) {
      object1->flags |= OBJECT1_SATUR;                                     [<A HREF="#flag1_18">18</A>]
   }
   
   if(object is still detected at edge of extracted profile (about 260arcsec)){
      object1->flags |= OBJECT1_TOO_LARGE;                                 [<A HREF="#flag1_24">24</A>]
   }

   if(measured profile includes points with a S/N <= 0) {
      object1->flags |= OBJECT1_BAD_RADIAL;                                [<A HREF="#flag1_15">15</A>]
   }
   
   if(central value of object more than <A HREF="#flag1_100">100</A> sigma below sky level) {
      object1->flags |= OBJECT1_BADSKY | OBJECT1_NOPETRO;                [<A HREF="#flag1_8">8</A>,<A HREF="#flag1_22">22</A>]
      use fallback value for "Petrosian" radius;
      give up measuring object in this band; something is horribly wrong.
   }

   if(radial profile has fewer than two points) {
      object1->flags |= OBJECT1_NOPROFILE;                                 [<A HREF="#flag1_7">7</A>]
      object1->flags |=
                       OBJECT1_NOPETRO | OBJECT1_ELLIPFAINT | OBJECT1_NOSTOKES;
      give up measuring Petrosian quantities, Stokes parameters, and
        isophotal quantities;                                         [<A HREF="#flag1_8">8</A>,<A HREF="#flag1_21">21</A>,<A HREF="#flag1_27">27</A>]
   }
/*
 * measure a few misc quantities
 */
   if(central surface brightness is below threshold for isophotal shape ||
      failed to fit ellipse at threshold +- delta) {
      object1->flags |= OBJECT1_ELLIPFAINT;                                [<A HREF="#flag1_27">27</A>]
      give up fitting ellipse;
   }

   if(failed to measure U or Q due to numerical difficulties) {
      object1->flags |= OBJECT1_NOSTOKES;                                  [<A HREF="#flag1_21">21</A>]
   }
/*
 * measure Petrosian quantities
 */
   while(surface brightness at innermost candidate for Petrosian radius
         is too low) {
      reject candidate;
      object1->flags |= OBJECT1_PETROFAINT;                                [<A HREF="#flag1_23">23</A>]
   }
   
   if(there are no Petrosian radii) {
      object1->flags |= OBJECT1_NOPETRO;                                   [<A HREF="#flag1_8">8</A>]
      if(we didn't reject any candidates for the Petrosian radius) {
         object1->flags |= OBJECT1_NOPETRO_BIG;                            [<A HREF="#flag1_10">10</A>]
         use outermost point in radial profile as "Petrosian" radius;
      } else {
         use fallback value for "Petrosian" radius;
      }
   } else {
      if(there is more than one Petrosian radius) {
         object1->flags |= OBJECT1_MANYPETRO;                              [<A HREF="#flag1_9">9</A>]
      }
   }
   
   if(more than one value of Petrosian 50% light radius) {
      object1->flags |= OBJECT1_MANYR50; /* how can this happen? */        [<A HREF="#flag1_13">13</A>]
   }
   if(more than one value of Petrosian 90% light radius) {
      object1->flags |= OBJECT1_MANYR90; /* how can this happen? */        [<A HREF="#flag1_14">14</A>]
   }
   if(object1->flags & OBJECT1_NOPETRO) {                                  [<A HREF="#flag1_8">8</A>]
      give up on errors for Petrosian quantities;
   }

   if(object is less than one (r') Petrosian radius from edge of frame) {
      object1->flags |= OBJECT1_INCOMPLETE_PROFILE;                        [<A HREF="#flag1_16">16</A>]
   }
/*
 * Measure fibre and psf counts
 */
   foreach type (fibre psf) {
      if(counts were contaminated by INTERP pixels) {                      [<A HREF="#flag1_17">17</A>]
         estimate errors from "real" pixels
         if(contamination exceeded 50% ||
            (obj1->flags2 & OBJECT2_BAD_COUNTS_ERROR)) {                   [<A HREF="#flag2_8">8</A>]
            obj1->flags2 |= OBJECT2_BAD_COUNTS_ERROR;                      [<A HREF="#flag2_8">8</A>]
         }
      }
   }
/*
 * Measure quantities about the centre determined in this band
 */
   if(local band is to close to the edge of the frame) {
      object1->flags |= OBJECT1_CANONICAL_CENTER | OBJECT1_EDGE;           [<A HREF="#flag1_0">0</A>][<A HREF="#flag1_1">2</A>]
      object1->flags2 |= OBJECT2_LOCAL_EDGE;                            [<A HREF="#flag2_7">7</A>]
      use (transformed) canonical centre;
   }
/*
 * mark measured as a bright object
 */
   if(measuring bright objects) {
      objc->flags |= OBJECT1_BRIGHT;                                       [<A HREF="#flag1_1">1</A>]
   }
/*
 * If object is a child and a blend, note that we don't (yet) run
 * deblender recursively. Moving objects appear blended, but they
 * aren't, so handle that case too
 */
   if((objc->flags & OBJECT1_CHILD) & (objc->flags & OBJECT1_BLENDED)) {   [<A HREF="#flag1_4">4</A><A HREF="#flag1_3">3</A>]
      if(objc->flags2 & OBJECT2_DEBLENDED_AS_MOVING) {                     [<A HREF="#flag2_0">0</A>]
         objc->flags &= ~OBJECT1_BLENDED;                                  [<A HREF="#flag1_3">3</A>]
      } else {
         objc->flags |= OBJECT1_NODEBLEND;                                 [<A HREF="#flag1_6">6</A>]
      }
   }
/*
 * Flag problems near the object's centre
 */
   if(centre of object is within 3 pixels of an interpolated pixel) {
      objc->flags2 &= OBJECT2_INTERP_CENTER;                               [<A HREF="#flag2_12">12</A>]
   }
   if(centre of object is within 3 pixels of a saturated pixel) {
      objc->flags2 &= OBJECT2_SATUR_CENTER;                                [<A HREF="#flag2_11">11</A>]
   }
/*
 * Classify object as e.g. star/galaxy
 */
   if(object1->flags2 & OBJECT2_INTERP_CENTER) {                           [<A HREF="#flag2_12">12</A>]
      object1->type = unknown;
   }

   if(!(object1->flags & OBJECT1_DETECTED)) ||                             [<A HREF="#flag1_32">32</A>]
      object1->flags2 & (OBJECT2_DEBLEND_NOPEAK | OBJECT2_INTERP_CENTER)) { [<A HREF="#flag2_14">14</A>,<A HREF="#flag2_12">12</A>]
      don't consider this band in objc's classification;
   }
/*
 * propagate flags to and from OBJC
 */
   if(objc->flags & OBJECT1_BLENDED) {                                     [<A HREF="#flag1_3">3</A>]
      object1->flags |= OBJECT1_BLENDED;                                   [<A HREF="#flag1_3">3</A>]
   }

   objc->flags |= object1->flags & (OBJECT1_EDGE |                         [<A HREF="#flag1_2">2</A>]
                                    OBJECT1_BLENDED |                      [<A HREF="#flag1_3">3</A>]
                                    OBJECT1_CHILD |                        [<A HREF="#flag1_4">4</A>]
                                    OBJECT1_NOPETRO |                      [<A HREF="#flag1_8">8</A>]
                                    OBJECT1_MANYPETRO |                    [<A HREF="#flag1_9">9</A>]
                                    OBJECT1_INTERP |                       [<A HREF="#flag1_17">17</A>]
                                    OBJECT1_CR |                           [<A HREF="#flag1_12">12</A>]
                                    OBJECT1_SATUR |                        [<A HREF="#flag1_18">18</A>]
                                    OBJECT1_NOTCHECKED |                   [<A HREF="#flag1_19">19</A>]
                                    OBJECT1_BINNED1 |                      [<A HREF="#flag1_28">28</A>]
                                    OBJECT1_BINNED2 |                      [<A HREF="#flag1_29">29</A>]
                                    OBJECT1_BINNED4);                      [<A HREF="#flag1_30">30</A>]
   objc->flags2 &= object1->flags2 & (OBJECT2_DEBLENDED_AS_MOVING |        [<A HREF="#flag2_0">1</A>]
                                      OBJECT2_NODEBLEND_MOVING |           [<A HREF="#flag2_1">1</A>]
                                      OBJECT2_TOO_FEW_DETECTIONS |         [<A HREF="#flag2_2">2</A>]
                                      OBJECT2_BAD_MOVING_FIT |             [<A HREF="#flag2_3">3</A>]
                                      OBJECT2_STATIONARY |                 [<A HREF="#flag2_4">4</A>]
                                      OBJECT2_PEAKS_TOO_CLOSE |            [<A HREF="#flag2_5">5</A>]
                                      OBJECT2_BAD_MOVING_FIT_CHILD |       [<A HREF="#flag2_9">9</A>]
                                      OBJECT2_DEBLEND_UNASSIGNED_FLUX |    [<A HREF="#flag2_10">10</A>]
                                      OBJECT2_SATUR_CENTER |               [<A HREF="#flag2_12">12</A>]
                                      OBJECT2_INTERP_CENTER |              [<A HREF="#flag2_11">11</A>]
                                      OBJECT2_DEBLENDED_AT_EDGE |          [<A HREF="#flag2_13">13</A>]
                                      OBJECT2_DEBLEND_NOPEAK);             [<A HREF="#flag2_14">14</A>]
}
</PRE>

<PRE>
find_velocity
{
   if(objc->flags2 & OBJECT2_DEBLENDED_AS_MOVING) {                        [<A HREF="#flag2_0">0</A>]
      we already have the velocity;
      return;
   }

   if(((object1->flags & OBJECT1_DETECTED) &&                              [<A HREF="#flag1_32">32</A>]
      !(object1->flags2 & (OBJECT2_DEBLEND_NOPEAK |                        [<A HREF="#flag2_14">14</A>]
                           OBJECT2_INTERP_CENTER)) &&                      [<A HREF="#flag2_12">12</A>]
      !(object1->flags & (OBJECT1_CANONICAL_CENTER |                       [<A HREF="#flag1_0">0</A>]
                          OBJECT1_PEAKCENTER |                             [<A HREF="#flag1_5">5</A>]
                          OBJECT2_INTERP_CENTER)) {                       [<A HREF="#flag2_12">12</A>]
      use centre in this band in velocity fit
   }

   if(chisq was too large) {
      objc->flags |= OBJECT2_BAD_MOVING_FIT;                               [<A HREF="#flag2_3">3</A>]
   }
}
</PRE>

<PRE>
deblender
{
   if(measuring bright objects && OBJECT1_BLENDED) {                       [<A HREF="#flag1_3">3</A>]
      objc->flags |= OBJECT1_NODEBLEND;                                    [<A HREF="#flag1_6">6</A>]
      give up on the object as it'll be reprocessed !BRIGHT;
   }

   if(there are too many peaks in object) {
      objc->flags |= OBJECT1_DEBLEND_TOO_MANY_PEAKS;                       [<A HREF="#flag1_11">11</A>]
      only use the n brightest peaks;
   }

   if(peaks are too close together) {
      forget the fainter peak;
      objc->flags |= OBJECT2_PEAKS_TOO_CLOSE;                             [<A HREF="#flag2_5">5</A>]
   }

   if(there's an "object" found at a different place in each band) {
      if(enough peaks in significantly different places) {
         objc->flags |= OBJECT1_MOVED;                                     [<A HREF="#flag1_31">31</A>]
      }
   }

   if(objc->flags & OBJECT1_MOVED) {                                       [<A HREF="#flag1_31">31</A>]
      objc->flags2 |= OBJECT2_DEBLENDED_AS_MOVING;                         [<A HREF="#flag2_0">0</A>]
      create extra MOVED child;
      child->flags |= OBJECT1_MOVED;                                       [<A HREF="#flag1_31">31</A>]
      child->flags2 |= OBJECT2_DEBLENDED_AS_MOVING;                        [<A HREF="#flag2_0">0</A>]
   }

   foreach(merged peak found in parent) {
      make_new_child_from_objc {
         if(child is detected in <= deblend_min_detect bands) {
            objc->parent->flags2 |= OBJECT2_TOO_FEW_DETECTIONS;            [<A HREF="#flag2_2">2</A>]
            don't create child;
	    continue;
         }

         if(peak is lablelled as MOVED) {
            child->flags |= OBJECT1_MOVED;                                 [<A HREF="#flag1_31">31</A>]
         }

         child->flags = objc->flags & (OBJECT1_EDGE |                      [<A HREF="#flag1_2">2</A>]
                                       OBJECT1_PEAKCENTER |                [<A HREF="#flag1_5">5</A>]
                                       OBJECT1_INTERP |                    [<A HREF="#flag1_17">17</A>]
                                       OBJECT1_NOTCHECKED |                [<A HREF="#flag1_19">19</A>]
                                       OBJECT1_SUBTRACTED);                [<A HREF="#flag1_20">20</A>]
         child->flags |= OBJECT1_CHILD;                                    [<A HREF="#flag1_4">4</A>]

         child_object1->flags = object1->flags & (OBJECT1_CANONICAL_CENTER | [<A HREF="#flag1_0">0</A>]
                                                  OBJECT1_EDGE |           [<A HREF="#flag1_2">2</A>]
                                                  OBJECT1_PEAKCENTER |     [<A HREF="#flag1_5">5</A>]
                                                  OBJECT1_NOTCHECKED |     [<A HREF="#flag1_19">19</A>]
                                                  OBJECT1_SUBTRACTED);     [<A HREF="#flag1_20">20</A>]
         child_object1->flags |= OBJECT1_CHILD;                            [<A HREF="#flag1_4">4</A>]

         if(a peak was found in this band) {
	    set centre from peak;
            child_object1->flags |= OBJECT1_BINNED1;                       [<A HREF="#flag1_28">28</A>]
         } else {
	    set centre from OBJC;
            child_object1->flags |= OBJECT1_CANONICAL_CENTER;              [<A HREF="#flag1_0">0</A>]
         }
      }
   }

   phObjcDeblend {
      if(objc will be OBJECT1_EDGE in next strip/field too) {              [<A HREF="#flag1_2">2</A>]
         objc->flags2 |= OBJECT2_DEBLENDED_AT_EDGE;                        [<A HREF="#flag2_13">13</A>]
         child->flags2 |= OBJECT2_DEBLENDED_AT_EDGE;                       [<A HREF="#flag2_13">13</A>]
         trim the part of objc's atlas image that's too close to edge of field;
      } else {
         if(objc->flags & OBJECT1_EDGE) {                                  [<A HREF="#flag1_2">2</A>]
            objc->flags |= OBJECT1_NODEBLEND;                              [<A HREF="#flag1_6">6</A>]
            give up, as edge objects invalidate assumptions made by deblender,
            and will be deblended in next strip/field anywayl
      }

      if(objc->flags & OBJECT1_MOVED) {                                    [<A HREF="#flag1_31">31</A>]
         find child with (child->flags2 & OBJECT2_DEBLENDED_AS_MOVING);    [<A HREF="#flag2_0">0</A>]
         if(phObjcDeblendMovingChild(moving_child) succeeds) {
            delete all children with OBJECT1_MOVED set, as we have decided [<A HREF="#flag1_31">31</A>]
            to treat them as part of their own moving object;
         }
      }

      deblend_template_find {
         if(!(objc->flags & OBJECT1_SATUR) &&                             [<A HREF="#flag1_18">18</A>]
            child is consistent with PSF) {
            Subtract PSF from parent and use PSF as template in this band;
            objc_object1->flags |= OBJECT1_DEBLENDED_AS_PSF;              [<A HREF="#flag1_25">25</A>]
         }
      
         if(template for this child is too large (more than half a frame)) {
            objc->parent->flags |= OBJECT1_TOO_LARGE | OBJECT1_NODEBLEND;[<A HREF="#flag1_6">6</A>,<A HREF="#flag1_24">24</A>]
            give up on deblending parent;
         }
         
         if(template + (smoothing length)/2 hangs over edge of frame in any band) {
            objc->parent->flags |= OBJECT1_EDGE | OBJECT1_NODEBLEND;      [<A HREF="#flag1_2">2</A>,<A HREF="#flag1_6">6</A>]
            give up on deblending parent;
         }

	 find templates for child;

	 if(we wouldn't have detected this child in any band) {
	    delete child;
	 }

         if(failed to find a template in this band) {
            object1->flags &= ~OBJECT1_DETECTED;                           [<A HREF="#flag1_32">32</A>]
            object1->flags |= OBJECT1_DEBLENDED_AS_PSF;                    [<A HREF="#flag1_25">25</A>]
            use PSF template;
         }
         
         objc->flags |= object1->flags & OBJECT1_DETECTED;                 [<A HREF="#flag1_32">32</A>]
      }
      
      setup Normal Equations, and solve for weights for each child;

      if(at least one possible child is rejected due to singular matrix) {
         objc->flags |= OBJECT1_DEBLEND_PRUNED;                            [<A HREF="#flag1_26">26</A>]
         object1->flags |= OBJECT1_DEBLEND_PRUNED;                         [<A HREF="#flag1_26">26</A>]
      }
      
      if(only one child remains) {
         objc->flags &= ~OBJECT1_BLENDED;                                  [<A HREF="#flag1_3">3</A>]
	 ensure that object's peaks correspond to those in the child,
         with OBJECT1_CANONICAL_CENTER and OBJECT1_DETECTED set correctly; [<A HREF="#flag1_0">0</A>,[<A HREF="#flag1_32">32</A>]
         no need to deblend;
      }

      if(object is detectable in this band, but wasn't seen due (usually) to the
         vaguaries of peak matching) {
         object1->flags |= OBJECT1_BINNED1;                                [<A HREF="#flag1_28">28</A>]
      }

      if(Petrosian flux in children> deblend_allowed_unassigned*(parent's petroCounts)) {
         objc->color[c]->flags2 |= OBJECT2_DEBLEND_UNASSIGNED_FLUX;        [<A HREF="#flag2_10">10</A>]
      }
      
      if(child includes CR pixels) {
         object1->flags |= OBJECT1_CR;                                     [<A HREF="#flag1_12">12</A>]
      }
      if(child includes interpolated pixels) {
         object1->flags |= OBJECT1_INTERP;                                 [<A HREF="#flag1_17">17</A>]
      }
      if(child includes saturated pixels) {
         object1->flags |= OBJECT1_SATUR;                                  [<A HREF="#flag1_18">18</A>]
      }
   }
}

phObjcDeblendMovingChild
{
   if(object is detected in <= 2 bands) {
      objc->parent->flags2 |= (OBJECT2_TOO_FEW_DETECTIONS |                [<A HREF="#flag2_2">2</A>]
			       OBJECT2_NODEBLEND_MOVING);                  [<A HREF="#flag2_1">1</A>]
      objc->parent->flags2 &= ~OBJECT2_DEBLENDED_AS_MOVING;                [<A HREF="#flag2_0">0</A>]
   }

   if(chi^2 for velocity fit is too large) {
      objc->parent->flags2 |= (OBJECT2_BAD_MOVING_FIT_CHILD |              [<A HREF="#flag2_9">9</A>]
			       OBJECT2_NODEBLEND_MOVING);                  [<A HREF="#flag2_1">1</A>]
      objc->parent->flags2 &= ~OBJECT2_DEBLENDED_AS_MOVING;                [<A HREF="#flag2_0">0</A>]
   }

   if(velocity is consistent with 0) {
      objc->parent->flags2 |= (OBJECT2_STATIONARY |                        [<A HREF="#flag2_4">4</A>]
			       OBJECT2_NODEBLEND_MOVING);                  [<A HREF="#flag2_1">1</A>]
      objc->parent->flags2 &= ~OBJECT2_DEBLENDED_AS_MOVING;                [<A HREF="#flag2_0">0</A>]
   }

   if(deblended as moving) {
      set centres for all OBJECT1_CANONICAL_CENTER objects                 [<A HREF="#flag1_0">0</A>]
      from the fit to the object's motion;
   }
}
</PRE>

</HTML>

<!--#include virtual="/includes/sdss_page_bottom.html"-->
